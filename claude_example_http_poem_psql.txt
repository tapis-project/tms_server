// Cargo.toml dependencies:
// [dependencies]
// poem = "3.1"
// tokio = { version = "1.41", features = ["full"] }
// sqlx = { version = "0.8", features = ["runtime-tokio-native-tls", "postgres"] }
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"

use poem::{
    get, handler, post, put, delete,
    listener::TcpListener,
    web::{Data, Json, Path},
    Route, Server, Result, Error, http::StatusCode,
};
use serde::{Deserialize, Serialize};
use sqlx::{PgPool, postgres::PgPoolOptions};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
struct User {
    id: i32,
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct UpdateUser {
    name: Option<String>,
    email: Option<String>,
}

// Get all users
#[handler]
async fn get_users(Data(pool): Data<&PgPool>) -> Result<Json<Vec<User>>> {
    let users = sqlx::query_as::<_, User>("SELECT id, name, email FROM users")
        .fetch_all(pool)
        .await
        .map_err(|e| Error::from_string(e.to_string(), StatusCode::INTERNAL_SERVER_ERROR))?;
    
    Ok(Json(users))
}

// Get user by ID
#[handler]
async fn get_user(Path(id): Path<i32>, Data(pool): Data<&PgPool>) -> Result<Json<User>> {
    let user = sqlx::query_as::<_, User>("SELECT id, name, email FROM users WHERE id = $1")
        .bind(id)
        .fetch_one(pool)
        .await
        .map_err(|e| Error::from_string(e.to_string(), StatusCode::NOT_FOUND))?;
    
    Ok(Json(user))
}

// Create new user
#[handler]
async fn create_user(
    Data(pool): Data<&PgPool>,
    Json(input): Json<CreateUser>,
) -> Result<Json<User>> {
    let user = sqlx::query_as::<_, User>(
        "INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email"
    )
    .bind(&input.name)
    .bind(&input.email)
    .fetch_one(pool)
    .await
    .map_err(|e| Error::from_string(e.to_string(), StatusCode::INTERNAL_SERVER_ERROR))?;
    
    Ok(Json(user))
}

// Update user
#[handler]
async fn update_user(
    Path(id): Path<i32>,
    Data(pool): Data<&PgPool>,
    Json(input): Json<UpdateUser>,
) -> Result<Json<User>> {
    let user = sqlx::query_as::<_, User>(
        "UPDATE users SET name = COALESCE($1, name), email = COALESCE($2, email) 
         WHERE id = $3 RETURNING id, name, email"
    )
    .bind(input.name)
    .bind(input.email)
    .bind(id)
    .fetch_one(pool)
    .await
    .map_err(|e| Error::from_string(e.to_string(), StatusCode::NOT_FOUND))?;
    
    Ok(Json(user))
}

// Delete user
#[handler]
async fn delete_user(Path(id): Path<i32>, Data(pool): Data<&PgPool>) -> Result<StatusCode> {
    let result = sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(id)
        .execute(pool)
        .await
        .map_err(|e| Error::from_string(e.to_string(), StatusCode::INTERNAL_SERVER_ERROR))?;
    
    if result.rows_affected() == 0 {
        return Err(Error::from_string("User not found", StatusCode::NOT_FOUND));
    }
    
    Ok(StatusCode::NO_CONTENT)
}

// Health check
#[handler]
async fn health() -> &'static str {
    "OK"
}

#[tokio::main]
async fn main() -> std::result::Result<(), std::io::Error> {
    // Database connection
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://postgres:password@localhost/mydb".to_string());
    
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    // Create table if not exists
    sqlx::query(
        "CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            email VARCHAR(255) NOT NULL UNIQUE
        )"
    )
    .execute(&pool)
    .await
    .expect("Failed to create table");
    
    println!("Connected to database");
    
    // Setup routes
    let app = Route::new()
        .at("/health", get(health))
        .at("/users", get(get_users).post(create_user))
        .at("/users/:id", get(get_user).put(update_user).delete(delete_user))
        .data(pool);
    
    println!("Server running on http://0.0.0.0:3000");
    
    Server::new(TcpListener::bind("0.0.0.0:3000"))
        .run(app)
        .await
}
